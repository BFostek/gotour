Incorporação
A incorporação de tipos fornece a parte final de compartilhamento e reutilização de estado e comportamento entre tipos.

* Incorporação
- [[https://www.ardanlabs.com/training/individual-on-demand/ultimate-go-bundle/][Assista allowo vídeo]]
- Need Financial Assistance, Use Our [[https://www.ardanlabs.com/scholarship/][Formulário de Bolsa]]

A incorporação de tipos fornece a parte final de compartilhamento e reutilização de 
estado e comportamento entre tipos. Através do uso da promoção do tipo interno, 
os campos e métodos de um tipo interno podem ser acessados diretamente por referências do tipo externo.

** Revisão de código

- *Exemplo* *1:* Declarando Campos
- *Exemplo* *2:* Tipos de incorporação
- *Exemplo* *3:* Tipos e interfaces incorporados
- *Exemplo* *4:* Implementações de interface de tipo externo e interno
	
.play embedding/example1.go
.play embedding/example2.go
.play embedding/example3.go		   
.play embedding/example4.go

** Mecânica de Incorporação ou Funcionamento da Incorporação

Este primeiro exemplo não mostra incorporação, apenas a declaração de dois tipos struct trabalhando juntos como um campo de um tipo para outro.

    type user struct {
        name  string
        email string
    }

    type admin struct {
        person user        // NOT Embedding
        level  string
    }

Isso é incorporação.

    type user struct {
        name  string
        email string
    }

    type admin struct {
        user               // Value Semantic Embedding
        level  string
    }

O campo person é removido e resta apenas o nome do tipo. Você também pode incorporar um tipo usando a semântica de ponteiro.

    type user struct {
        name  string
        email string
    }

    type admin struct {
        *user              // Pointer Semantic Embedding
        level  string
    }

Neste caso, o ponteiro do tipo é incorporado. Em ambos os casos, o acesso ao valor incorporado é feito através do uso do nome do tipo.

A melhor maneira de pensar sobre a incorporação é ver o tipo *user* como um tipo interno e o tipo
*admin* como um tipo externo. É essa relação de tipo interno/externo que é mágica,
pois com a incorporação, tudo relacionado ao tipo interno (tanto campos quanto métodos)
pode ser promovido para o tipo externo.

    type user struct {
        name  string
        email string
    }

    func (u *user) notify() {
        fmt.Printf("Sending user email To %s<%s>\n",
            u.name,
            u.email)
    }

    type admin struct {
        *user              // Pointer Semantic Embedding
        level  string
    }

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        ad.user.notify()
        ad.notify() // Outer type promotion
    }

Resultado:

    Sending user email To john smith<john@yahoo.com>
    Sending user email To john smith<john@yahoo.com>

Depois de adicionar um método chamado *notify* para o tipo *user* e, em seguida, uma pequena função *main*.
Você pode ver que a saída é a mesma, quer você chame o método *notify* diretamente através do valor do ponteiro interno 
ou através do valor do tipo externo. O método *notify* declarado para o tipo *user* é acessível diretamente pelo valor do tipo *admin*.

Embora isso pareça herança, você deve ter cuidado. Isso não se trata de reutilizar estado, mas de promover comportamento.

    type notifier interface {
        notify()
    }

    func sendNotification(n notifier) {
        n.notify()
    }

Now you add an interface and a polymorphic function that accepts any concrete value
that implements the full method set of behavior defined by the notifier interface.
Which is just a method named notify.

Agora, você adiciona uma interface e uma função polimórfica que aceita qualquer valor concreto
que implementa o conjunto completo de métodos de comportamento definidos pela interface *notifier*.
Que é apenas um método chamado *notify*.

Because of embedding and promotion, values of type admin now implement the notifier
interface.


Devido à incorporação e à promoção, os valores do tipo "admin" agora implementam a interface "notificador".

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        sendNotification(&ad)
    }

Output:

    Sending user email To john smith<john@yahoo.com>

You can send the address of the admin value into the polymorphic function since
embedding promotes the notify behavior up to the admin type.

    type admin struct {
        *user  // Pointer Semantic Embedding
        level  string
    }

    func (a *admin) notify() {
        fmt.Printf("Sending admin Email To %s<%s>\n",
            a.name,
            a.email)
    }

When the outer type implements a method already implemented by the inner type,
the promotion doesn’t take place.

    func main() {
        ad := admin{
            user: &user{
                name:  "john smith",
                email: "john@yahoo.com",
            },
            level: "super",
        }

        sendNotification(&ad)
    }

Output:
    
    Sending admin email To john smith<john@yahoo.com>

You can see the outer type’s method is now being executed.

** Notes

- Embedding types allow us to share state or behavior between types.
- The inner type never loses its identity.
- This is not inheritance.
- Through promotion, inner type fields and methods can be accessed through the outer type.
- The outer type can override the inner type's behavior.

** Extra Reading

- [[https://www.ardanlabs.com/blog/2014/05/methods-interfaces-and-embedded-types.html][Methods, Interfaces and Embedded Types in Go]] - William Kennedy    
- [[https://rakyll.org/typesystem/][Embedding is not inheritance]] - JBD  

* Exercises

Use the template as a starting point to complete the exercises. A possible solution is provided.

** Exercise 1

Edit the code from the template. Add a new type CachingFeed which embeds Feed and
overrides the Fetch method.

.play embedding/exercise1.go
.play embedding/answer1.go
